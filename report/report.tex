\documentclass[a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{hyperref}

\lstset{language=Java}
\hypersetup{%
    pdfauthor = {Martin Barksten, Victor Koronen},
    pdftitle = {Compiler Construction},
    pdfsubject = {DD2488},
    pdfkeywords = {compiler},
    pdfcreator = {LaTeX with hyperref package},
    pdfproducer = {pdflatex}
}

\title{Compiler Construction}
\author{%
    Martin Barksten <\href{mailto:barksten@kth.se}{barksten@kth.se}> \and
    Victor Koronen <\href{mailto:koronen@kth.se}{koronen@kth.se}>
}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Introduction}

This document describes the design and implementation of a compiler for a subset
of the Java language know as MiniJava \cite{minijavaproject} (with some
adaptations \cite{dd2488project} for the course DD2488 at KTH).

The document begins with a section about the structure of the program, followed
by a section giving an overview of the code and finally a section about how to
build, test and run the compiler.

\section{Structure}

This section gives a description of how the program is structured. The sections
come in the order of steps when compiling, beginning with the lexing and parsing
steps and ending with the assembling. The compiler compiles to the JVM with help
from the Jasmin assembler \cite{jasmin}. This allows us to skips a lot of common
backend steps, such as Immediate Representation, Control Flow Analysis and
Register Allocation, since this is all taken care of by Jasmin.

\subsection{Lexer and Parser}

Lexing and parsing is done using JavaCC \cite{javacc}, a Compiler Compiler for
Java generating LL-parsers. We also considered using ANTLR \cite{antlr}, a
parser generator generating LR-parsers. After some experimentation with both
libraries we decided to use JavaCC, mainly because we got the impression that
JavaCC is more well-used and better documented.

JavaCC handles tokenization and allows the programmer to write an LL grammar in
\texttt{.jj} files, which then JavaCC then ``compiles'' to Java files. In order
to be able to use a JavaCC-generated LL-parser, though, the given grammar had to
have all left-recursion eliminated, and \textit{Exp} operators had to be given the
right precedence.

Eliminating left-recursion can be done simply in JavaCC by using the
ability to match $0$ or more possible productions. The grammar

$$A \rightarrow A + B$$

can be converted to

$$A \rightarrow B (+ B)*$$

where star represents the ability to match $0$ or more times. Rewriting all
productions this way allowed us to eliminate all left-recursion.

The other problem was to give operators the right precedence. This was
accomplished by following a simple rule. Assume once again that we have the
following grammar

$$A \rightarrow B + B$$
$$A \rightarrow B \times B$$

and we want $\times$ to have higher precedence than $+$. We can simply rewrite it as

$$A \rightarrow B (+ B)*$$
$$B \rightarrow C (\times C)*$$

which will accomplish the goal of giving $\times$ higher precedence than $+$.

\subsection{Abstract Syntax Tree}

Constructing the Abstract Syntax Tree (AST) first requires creating all classes
necessary to represent it, one class for each unique terminator. The AST is
constructed during the parsing step using JavaCC. When, for example, a Plus
operator is found, we will continue the parsing to find the left and right
expression and then create an instance of the Plus class. This object is then
returned from the grammar rule.

\subsection{Type checking}

The type checking is done in two passes. The first pass binds all methods and
variables to their types, and the second pass checks that all statements and
expressions operate on the right types. In order to perform these two steps we
need to recursively visit the entire AST, which we do by using the visitor
pattern.

The visitor pattern allows us to keep all the traversal logic in a single class,
as opposed to having it spread out across all AST node classes
\cite{oodesignvisitor}. This should help make the type checking process
perspicuous.

In order to save the types we use a symbol table to map an identifier to a
corresponding type. We implement the symbol table using three different
subtables: a program table, a class table and a method table. Each table saves
slightly different information, which is why we chose to implement it in this
fashion. The program table maps all class identifiers to their respective class
table. The class tables map the method identifiers to their respective method
tables and also keeps track of what fields the class has, as well as an optional
super class. Finally the method table maps variable identifiers to their types.
The method table also keeps track of which variables are locals and which are
parameters.

When binding identifiers to types we traverse the tree and whenever we encounter
the declaration of a class, method, field or variable we add an entry to the
proper table. Classes are added to the program table, methods and fields to the
corresponding class table and variables to the corresponding method table.

The program table, allowing access to all other tables, is then passed to the
visitor used for the second pass. In the second pass we once again traverse the
tree checking that all operations on variables is correct. Additionally when
calling a method we check that the object it is called on has the method defined
for it. This is once again done using a visitor, and traversing the tree
recursively.

\subsection{Assembling}

Assembling is done by traversing the AST, translating AST nodes into Jasmin
assembly.

\section{Code overview}

\begin{description}
\item[\texttt{frame}] Package containing interfaces for abstractions of frames,
    records and variable accesses.
    \begin{description}
        \item[\texttt{frame.VMAccess}] Interface for declaring, loading and
            storing a variable on a VM.
        \item[\texttt{frame.VMFrame}] Interface for handling frames on a VM.
        \item[\texttt{frame.VMRecord}] Interface for handling heap objects on a
            VM.
    \end{description}
\item[\texttt{jvm}] Package containing implementations of the frame, record and
    variable access interfaces for the JVM.
    \begin{description}
        \item[\texttt{jvm.Frame}] Implementation of the frame handling interface
            for the JVM.
        \item[\texttt{jvm.Hardware}] Implementations of variable and method
            signatures for the JVM.
        \item[\texttt{jvm.Record}] Implementation of the heap object interface
            for the JVM.
    \end{description}
\item[\texttt{mjc}] Package containing the executable main class and the parser
    code.
    \begin{description}
        \item[\texttt{mjc.JVMMain}] The main JVM executable. Parses command line
            parameters, instantiates collaborator objects (such as the parser)
            and orchestrates interaction between the collaborators to produce
            the desired result.
        \item[\texttt{mjc.Parser}] The JavaCC-generated LL-parser.
    \end{description}
\item[\texttt{symbol}] Package containing abstractions of symbols and the symbol
    table.
    \begin{description}
        \item[\texttt{symbol.Symbol}] The abstraction of a symbol.
        \item[\texttt{symbol.ProgramTable}] The program symbol subtable.
        \item[\texttt{symbol.ClassTable}] The class symbol subtable.
        \item[\texttt{symbol.MethodTable}] The method symbol subtable.
    \end{description}
\item[\texttt{syntaxtree}] Package containing class definitions for all AST
    nodes.
\item[\texttt{temp}] Package containing abstractions of assembly level labels
    and variables.
    \begin{description}
        \item[\texttt{temp.Label}] The abstraction of a label.
        \item[\texttt{temp.Temp}] The abstraction of a variable.
    \end{description}
\item[\texttt{visitor}] Package containing implementations of visitors used to
    traverse tree structures, such as the AST.
    \begin{description}
        \item[\texttt{visitor.TypeDefVisitor}] Performs the first part of type
            checking. Traverses the AST and builds a symbol table structure.
        \item[\texttt{visitor.TypeCheckVisitor}] Performs the second part of
            type checking. Traverses the AST and checks types with help from the
            aforementioned symbol table.
        \item[\texttt{visitor.JVMVisitor}] Traverses the AST and writes Jasmin
            assembly.
    \end{description}
\end{description}

\section{Building, testing and running}

The compiler can be built using the Java build tool Apache Ant\texttrademark.
Just issue the command \texttt{ant} from the compiler root directory and Ant
will generate the parser using JavaCC, compile the compiler and compress all JVM
bytecode into a JAR archive.

Testing the compiler can be done by using the script \texttt{./script/test}. It
will first invoke Ant to ensure the compiler has been built and then proceed to
test the compiler against the test cases found in the directory
\texttt{testcases/}.

Testing the compiler can be done by using the script \texttt{./script/run}.
Given a MiniJava source file it will try to compile the file using our compiler
and then to execute the generated program using the system Java runtime.

\appendix

\section{Parsing}

During the parsing the most interesting bug was how Not bound.

\begin{lstlisting}
!false && true
\end{lstlisting}

The boolean expression above would be parsed as

\begin{lstlisting}
!(false && true)
\end{lstlisting}

This in turn caused some strange behavior that caused quite some trouble debugging. This bug was not found until during the JVM assembly. It took considerable time to debug what caused the problem due to the fact that almost all boolean logic during the JVM assembly was buggy (more about that in section JVM assembly). Once discovered that the bug was during the parsing, resolving it was easy.

One thing learned from this experience is to debug more in earlier steps. We never properly tested the parser, which caused other hard to find bugs during the JVM assembly and type checking.

\section{JVM Assembly}

When doing the JVM assembly several bugs related to logical operators were found and debugging attempted. The bug would arise when writing code as below.

\begin{lstlisting}
!(1 < 2)
\end{lstlisting}

The boolean expression would evaluate as false, when it is true. Finding why the bug arose was easy â€“ branching on true or false was clearly wrong. However, correcting it took quite some time due to how the branching works.

The JVM bytecode's built in ifeq compares to zero, which we internally used as false. So if ifeq branched, the value was false rather than true. This behavior made every single node in the AST related to booleans behave incorrectly.

Other minor bugs also arose when converting to bytecode, however these were all fixed faster and easier.

\begin{thebibliography}{99}

\bibitem{minijavaproject}
    J.~Cangussu, J.~Palsberg, V.~Samanta,
    \emph{Modern Compiler Implementation in Java: the MiniJava Project},
    <\url{http://www.cambridge.org/resources/052182060X/}>, retrieved 2014-04-27

\bibitem{dd2488project}
    T.~Granlund,
    \emph{Project in DD2488, Compiler Construction (komp14)},
    <\url{http://www.csc.kth.se/utbildning/kth/kurser/DD2488/komp14/project/}>, retrieved 2014-04-27

\bibitem{jasmin}
    J.~Meyer,
    \emph{JASMIN HOME PAGE} (2004),
    <\url{http://jasmin.sourceforge.net/}>, retrieved 2014-04-27

\bibitem{javacc}
    JavaCC contributors,
    \emph{Java Compiler Compiler\texttrademark (JavaCC\texttrademark) -- The Java Parser Generator},
    <\url{https://javacc.java.net/}>, retrieved 2014-04-27

\bibitem{antlr}
    ANTLR~/~T.~Parr,
    \emph{ANTLR},
    <\url{http://www.antlr.org/}>, retrieved 2014-05-08

\bibitem{oodesignvisitor}
    A.~Ianculescu,
    \emph{Visitor Pattern},
    <\url{http://www.oodesign.com/visitor-pattern.html}>, retrieved 2014-05-08

\end{thebibliography}

\end{document}
