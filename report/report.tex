\documentclass[a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{hyperref}
\hypersetup{%
    pdfauthor = {Martin Barksten, Victor Koronen},
    pdftitle = {Compiler Construction},
    pdfsubject = {DD2488},
    pdfkeywords = {compiler},
    pdfcreator = {LaTeX with hyperref package},
    pdfproducer = {pdflatex}
}

\title{Compiler Construction}
\author{%
    Martin Barksten <\href{mailto:barksten@kth.se}{barksten@kth.se}> \and
    Victor Koronen <\href{mailto:koronen@kth.se}{koronen@kth.se}>
}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Introduction}

This document describes the design and implementation of a compiler for a subset
of the Java language know as MiniJava \cite{minijavaproject} (with some
adaptations \cite{dd2488project} for the course DD2488 at KTH).

The document begins with a section about the structure of the program, followed
by a section giving an overview of the code and finally a section about how to
build, test and run the compiler.

\section{Structure}

This section gives a description of how the program is structured. The sections
come in the order of steps when compiling, beginning with the lexing and parsing
steps and ending with the assembling. The compiler compiles to the JVM with help
from the Jasmin assembler \cite{jasmin}. This allows us to skips a lot of common
backend, steps such as Immediate Representation, Control Flow Analysis and
Register Allocation, since this is all taken care of by Jasmin.

\subsection{Lexer and Parser}

Lexing and parsing is done using JavaCC \cite{javacc}, a Compiler Compiler for
Java. JavaCC handles tokenization and allows the programmer to write an LL
grammar in \texttt{.jj} files, which then JavaCC then ``compiles'' to Java
files. In order to be able to use a JavaCC-generated LL-parser, though, the
given grammar had to have all left-recursion eliminated, and Exp operators had
to be given the right precedence.

Eliminating left-recursion can be done simply in JavaCC by using the
ability to match $0$ or more possible productions. The grammar

$$A \rightarrow A + B$$

can be converted to

$$A \rightarrow B (+ B)*$$

where star represents the ability to match $0$ or more times. Rewriting all
productions this way allowed us to eliminate all left-recursion.

The other problem was to give operators the right precedence. This was
accomplished by following a simple rule. Assume once again that we have the
following grammar

$$A \rightarrow B + B$$
$$A \rightarrow B - B$$

and we want $-$ to have higher precedence than $+$. We can simply rewrite it as

$$A \rightarrow B + B$$
$$B \rightarrow C - C$$

which will accomplish the goal of giving $-$ higher precendence than $+$.

\subsection{Abstract Syntax Tree}

Constructing the Abstract Syntax Tree (AST) first requires creating all classes
necessary to represent it, one class for each unique terminator. The AST is
constructed during the parsing step using JavaCC. When, for example, a Plus
operator is found, we will continue the parsing to find the left and right
expression and then create an instance of the Plus class. This object is then
returned from the grammar rule.

\subsection{Type checking}

The type checking is done in two passes. The first pass binds all methods and
variables to their types, and the second pass checks that all statements and
expressions operate on the right types. In order to perform these two steps we
need to recursively visit the entire AST, which we do by using the Visitor
pattern.

The visitor pattern allows us\ldots

In order to save the types we use a symbol table to map an identifier to a
corresponding type. We use three different symbol tables: a program table, a
class table and a method table. Each table saves slightly different information.
The program table maps all class identifiers to their respective class table.
The class tables map the method identifiers to their respective method tables
and also keeps track of what fields the class has, as well as an optional super
class. Finally the method table maps variable identifiers to their types. The
method table also keeps track of which variables are locals and which are
parameters.

When binding identifiers to types we traverse the tree and whenever we encounter
the declaration of a class, method, field or variable we add an entry to the
proper table. Classes are added to the program table, methods and fields to the
corresponding class table and variables to the corresponding method table.

The program table, allowing access to all other tables, is then passed to the
visitor used for the second pass. In the second pass we once again traverse the
tree checking that all operations on variables is correct. Additionally when
calling a method we check that the object it is called on has the method defined
for it. This is once again done using a visitor, and traversing the tree
recursively.

\subsection{Assembling}

Assembling is done by traversing the AST, translating AST nodes into Jasmin
assembly.

\section{Code overview}

\begin{description}
\item[\texttt{mjc}] Package containing executable main classes and the parser
    code.
    \begin{description}
        \item[\texttt{mjc.JVMMain}] The main JVM executable.
        \item[\texttt{mjc.Parser}] The JavaCC-generated LL-parser.
    \end{description}
\item[\texttt{symbol}] Package containing abstractions of symbols and symbol
    tables.
\item[\texttt{syntaxtree}] Package containing class definitions for all AST
    nodes.
\item[\texttt{visitor}] Package containing implementations of visitors used to
    traverse tree structures, such as the AST.
    \begin{description}
        \item[\texttt{visitor.TypeDefVisitor}] Traverses the AST and builds
            a symbol table structure.
        \item[\texttt{visitor.TypeCheckVisitor}] Traverses the AST and checks
            types with help from the aforementioned symbol table.
        \item[\texttt{visitor.JVMVisitor}] Traverses the AST and writes Jasmin
            assembly.
    \end{description}
\end{description}

\section{Building, testing and running}

\begin{thebibliography}{99}

\bibitem{minijavaproject}
    J.~Cangussu, J.~Palsberg, V.~Samanta,
    \emph{Modern Compiler Implementation in Java: the MiniJava Project},
    <\url{http://www.cambridge.org/resources/052182060X/}>, retrieved 2014-04-27

\bibitem{dd2488project}
    T.~Granlund,
    \emph{Project in DD2488, Compiler Construction (komp14)},
    <\url{http://www.csc.kth.se/utbildning/kth/kurser/DD2488/komp14/project/}>, retrieved 2014-04-27

\bibitem{jasmin}
    J.~Meyer,
    \emph{JASMIN HOME PAGE} (2004),
    <\url{http://jasmin.sourceforge.net/}>, retrieved 2014-04-27

\bibitem{javacc}
    JavaCC contributors,
    \emph{Java Compiler Compiler\texttrademark (JavaCC\texttrademark) -- The Java Parser Generator},
    <\url{https://javacc.java.net/}>, retrieved 2014-04-27

\end{thebibliography}

\end{document}
