PARSER_BEGIN(Parser)

import mjc.Exp;
import mjc.Num;
import mjc.BinaryExp;
import mjc.IdExp;

public class Parser {
    public static void main(String[] args) throws Exception {
        try {
            new Parser(new java.io.StringReader(args[0])).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
            System.exit(1);
        }
    }
}

PARSER_END(Parser)

SKIP: {
    " " |
    "\t" |
    "\n" |
    "\r"
}

/* Reserved keywords. */
TOKEN: {
    <BOOLEAN: "boolean"> |
    <CLASS: "class"> |
    <ELSE: "else"> |
    <IF: "if"> |
    <INT: "int"> |
    <LENGTH: "length"> |
    <NEW: "new"> |
    <PUBLIC: "public"> |
    <RETURN: "return"> |
    <STATIC: "static"> |
    <STRING: "String"> |
    <SYSOUT: "System.out.println"> |
    <THIS: "this"> |
    <VOID: "void"> |
    <WHILE: "while">
}

/* Operators. */
TOKEN: {
    <ASSIGN: "="> |
    <LAND: "&&"> |
    <LNEG: "!"> |
    <LT: "<"> |
    <MINUS: "-"> |
    <PLUS: "+"> |
    <TIMES: "*">
}

/* Misc. */
TOKEN: {
    <COMMA: ","> |
    <DOT: "."> |
    <LBRACE: "{"> | <RBRACE: "}"> |
    <LBRACKET: "["> | <RBRACKET: "]"> |
    <LPAREN: "("> | <RPAREN: ")"> |
    <SEMICOLON: ";">
}

/* Literals and identifiers. */
TOKEN: {
    <TRUE: "true"> |
    <FALSE: "false"> |
    <INT_LIT: "0" | ["1"-"9"](["0"-"9"])*> |
    <ID: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

void S(): {}
{
    MainClass() ( ClassDecl() )* <EOF>
}

void MainClass(): {}
{
    <CLASS> <ID>
    <LBRACE>
        <PUBLIC> <STATIC> <VOID> <ID> <LPAREN> <STRING> <LBRACKET> <RBRACKET> <ID> <RPAREN>
        <LBRACE>
            ( LOOKAHEAD(2) VarDecl() )*
            ( Stmt() )*
        <RBRACE>
    <RBRACE>
}

void ClassDecl(): {}
{
    <CLASS> <ID>
    <LBRACE>
        ( VarDecl() )*
        ( MethodDecl() )*
    <RBRACE>
}

void VarDecl(): {}
{
    Type() <ID> <SEMICOLON>
}

void MethodDecl(): {}
{
    <PUBLIC> Type() <ID> <LPAREN> FormalList() <RPAREN>
    <LBRACE>
        ( LOOKAHEAD(2) VarDecl() )*
        ( Stmt() )*
        <RETURN> Exp() <SEMICOLON>
    <RBRACE>
}

void FormalList(): {}
{
    Type() <ID> ( FormalRest() )*
|
    {}
}

void FormalRest(): {}
{
    <COMMA> Type() <ID>
}

void Type(): {}
{
    <INT> ( <LBRACKET> <RBRACKET> )?
|
    <BOOLEAN>
|
    <ID>
}

void Stmt(): {}
{
    <LBRACE> ( Stmt() )* <RBRACE>
|
    <IF> <LPAREN> Exp() <RPAREN> Stmt() <ELSE> Stmt()
|
    <WHILE> <LPAREN> Exp() <RPAREN> Stmt()
|
    <SYSOUT> <LPAREN> Exp() <RPAREN> <SEMICOLON>
|
    <ID> (
        <ASSIGN> Exp() |
        <LBRACKET> Exp() <RBRACKET> <ASSIGN> Exp()
    )
    <SEMICOLON>
}

void Exp(): {}
{
    Relational() ExpPrim()
}

// FIXME: Doesn't work properly
void ExpPrim(): {}
{
    <LAND> Exp()
|
    (
        <DOT> (
            <ID> <LPAREN> ExpList() <RPAREN> |
            <LENGTH>
        ) |
        <LBRACKET> Exp() <RBRACKET>
    )
|
    {}
}

void ExpList(): {}
{
    Exp() ( ExpRest() )*
|
    {}
}

void ExpRest(): {}
{
    <COMMA> Exp()
}

void Relational(): {}
{
    Additive() RelationalPrim()
}

void RelationalPrim(): {}
{
    <LT> Relational()
|
    {}
}

void Additive(): {}
{
    Multiplicative() AdditivePrim()
}

void AdditivePrim(): {}
{
    <PLUS> Additive()
|
    <MINUS> Additive()
|
    {}
}

void Multiplicative(): {}
{
    ExpTerminator() MultiplicativePrim()
}

void MultiplicativePrim(): {}
{
    <TIMES> Multiplicative()
|
    {}
}

void ExpTerminator(): {}
{
    <INT_LIT>
|
    <TRUE>
|
    <FALSE>
|
    <ID>
|
    <THIS>
|
    <NEW> (<INT> <LBRACKET> Exp() <RBRACKET> | <ID> <LPAREN> <RPAREN>)
|
    <LNEG> Exp()
|
    <LPAREN> Exp() <RPAREN>
}
